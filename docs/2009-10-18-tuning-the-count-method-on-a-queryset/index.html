<!DOCTYPE html>
<html lang="en">
<head>
<!-- Last built: 2021-10-05T03:24:55+00:00 -->
<meta charset="utf-8" />
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Andy McKay :: Tuning the count method on a queryset</title>
<link href="/css/style.css?v=2021-10-05T03:24:55+00:00" rel="stylesheet" type="text/css">
<link href="/css/pygments.css?v=2021-10-05T03:24:55+00:00" rel="stylesheet" type="text/css">
<link rel="shortcut icon" type="image/ico" href="/images/favicon.ico" />
<link rel="alternate" href="/atom.xml" type="application/atom+xml">
<meta name="viewport" content="initial-scale=1, maximum-scale=1">
</head>
<body>
<div id="main">
<header>
  <h1><a href="/">Andy McKay</a></h1>
</header>
<section>
<article>
<div class="meta">Oct 18, 2009</div>
<h2><a href="/2009-10-18-tuning-the-count-method-on-a-queryset/">Tuning the count method on a queryset</a></h2>
<hr class="florished">
<p>Reprinted from <a href="http://djangozen.com/blog/tuning-the-count-method-on-a-queryset">Djangozen</a>.</p>
<p>The other week I faced a real slow down on <a class="external-link" href="http://www.areciboapp.com">Arecibo</a> due to a high number of errors being generated by a few other sites. At the time I started to find out how bad Postgres is compared to MySQL in terms of performance when doing a SQL count. MySQL does <a class="external-link" href="http://www.wikivs.com/wiki/MySQL_vs_PostgreSQL#COUNT.28.2A.29">more work to make that faster</a>.</p>
<p>In Arecibo, we present a list of all the errors that have recently occured. This page is paginated using the <a class="external-link" href="http://www.djangoproject.com/documentation/models/pagination/">Django pagination</a> class. To figure out how big the result set is and hence how many pages you have,&nbsp; the default pagination class will call the method <em>count</em> on the queryset.</p>
<p>So how can we make this faster, the first obvious strategy, change count on your query set. To do this write a custom object manager and then create your own count. For example:</p>
<pre>def count(self):
    # rather stupid count
    return 999999
</pre>
<p>Hmm that actually works pretty well on some larger Arecibo error pages, because we don't really need to do a count if you've got a lot of results. If you do this, then the pagination class just thinks the list is big and the user sees lots of "next" links.</p>
<p>How about caching it? That's straightforward too.</p>
<pre>def count(self):
    # not fully tested
    if cache.get("count", None):
        return cache["count"]
    count = self.get_query_set().count()
    cache.set("count", count)
    return count
</pre>
<p>Hmm again, ok. The problem is that this is fast on the second hit. The first hit is slow.</p>
<p>But you've got the general idea. The problem with these is that they change the <em>ObjectManager</em> and hence the change all count calls for that model (unless I start having multiple ObjectManagers). Actually for me that's a problem in my application. I still want the django-admin and other parts of the site to work and this change broke quite a lot of unit tests as I quickly looked for a solution.</p>
<p>You could also overwrite count on a per query set basis. Since there was on key view in Arecibo that was causing the problem, I focused on that and wrote the following:</p>
<pre>class CountProxy:
    def __call__(self):
        # do something clever here, cache, guess etc
        # to create a count
        return count
</pre>
<p>Next in your view, assign the CountProxy to the object.</p>
<pre>queryset = Error.objects.filter(...)
queryset.count = CountProxy()
Paginator(queryset, ...)
</pre>
<p>In the end my <em>CountProxy</em> class got quite complicated as it did work to cache and optimise the query based on the filtering. The nice thing is that you have an opportunity to make count as complex and as custom you'd like at this point. Add in some Postgres index tuning and things turned out a lot better. The end result was that I got page that was taking sometimes around 8 seconds (it was a bad day), down to about 40ms.</p>
<p>The ability to do fine grained control on that <em>count</em> can be quite useful.</p>

<div id="navigation">
  <a href="/2009-09-15-djangocon-2009-review/">&laquo; older</a>
  <a href="/2009-10-25-announcing-django-training/">newer &raquo;</a>
</div>

</article>
</section>
<footer>
<div id="thefooter">
  <p>
    <a href="/">Home</a> &bull;
    <a href="/archives/">Archives</a>
  </p>
  <p>
    I work at <a href="https://github.com">GitHub</a>. I used to be at <a href="https://www.mozilla.com">Mozilla</a>.<br />
    <a href="mailto:andy@mckay.pub">andy@mckay.pub</a> &bull;
    <a href="https://mckay.pub.ca/atom.xml">RSS</a><br />
    <a href="https://twitter.com/andymckay">Twitter</a> &bull;
    <a href="https://www.linkedin.com/pub/andy-mckay/11/225/aa1">Linkedin</a> &bull;
    <a href="https://github.com/andymckay">GitHub</a><br />
  </p>
</div>
</footer>
</div>
</body>
</html>
